%!TEX root = project.tex

\chapter*{About this project}
\paragraph{Abstract}
This project is an Social Media platform where you can create communities, post up discussions and follow your friends. . . .  etc etc

\paragraph{Authors}
Aaron Moran, Conor Shortt, Thomas Kenny.

\chapter{Introduction}
The final year project requires you to show initiative, consistency and the ability to showcase what you have learned over the course of four years.
Three members consist of Aaron Moran, Conor Shortt and Thomas Kenny. We are like minded students that share an interest for learning new skills and developing our ability as computer programmers. We have different skills that when combined complement each other from creativity to problem solving. With our interest in social media we decided early on that a social media website was a project that we felt we all could contribute too. A social media website requires multiple features, the in depth use of a database and an engaging UI. We were confident from the start with the team we have we could develop a website that could meet the standards of the websites out in the world today.
Before any developing took place, it was crucial we carried out in depth research into the top social media websites , how we were going to develop it , type of database to use and too draw up a timeline of goals/targets.

\newpage

\chapter{Context}
\begin{itemize}
\item Provide a context for your project.

\item Set out the objectives of the project
\item Briefly list each chapter / section and provide a 1-2 line description of what each section contains.
\item List the resource URL (GitHub address) for the project and provide a brief list of the main elements at the URL.
\end{itemize}

\section{Filler}


\chapter{Methodology}
About one to two pages.
Describe the way you went about your project:
\begin{itemize}
\item Agile / incremental and iterative approach to development. Planning, meetings.
\item What about validation and testing? Junit or some other framework.


For the development of this application, we decided the best approach to take was to use Agile. Agile is a methodology focused around iterative development. Using this method requires a team to work collaboratively and consistently. Before we started any development it was important to have a clear plan of what the features we wanted to incorporate and develop. Living in the same house proved useful in these times as we were able to have in-person meetings. Our first meeting we drew up a plan of how we were going to develop this application. Our first aim of was to agree on a development stack. After research into numerous development stacks such as the MEAN stack and MERN stack we decided on the MERN stack. We carried out extensive research into the factors that are common to all great websites, such as:

\item \textbf{Functional} - Probably the most important aspect of every website. It must work quickly and as expected. Page loading times must be kept as low as possible, especially when working with large amounts of data - this was a big issue that we encountered when dealing with images.
\item \textbf{Easy to Use} - User Experience (UX) plays a key role in helping visitors use, understand, and continue to use an application. If an application is difficult to use/understand, you can guarantee that a user won't stay longer than a few seconds.
\item \textbf{Robustness} - The application should work when used on different devices, the page should automatically resize and adjust when used on different sized screens.

With our choice of stack agreed upon, the next step was dividing the roles in the group. Conor and Thomas have an interest in back-end development and Aaron was keen on developing the Front-end. The first meeting was beneficial as we had a concrete foundation to build upon. \newline
We decided the best approach to development was to work on two - three features a week. We set up a whiteboard with a list of features to be developed, every week we would divide the features between the three of us. An example of our work process is shown below.
\begin{center}
  \includegraphics[scale=0.09]{img/whiteboard.jpg}
\end{center}
Each week we would have a meeting detailing the work done and evaluate the features developed. This was an important process as we got to discover what we could improve and what works well. If something needed improving we would put it back on the list for future meetings. If a feature was functional and proved to be efficient we would cross it off the board. \newline
These meetings were also valuable for tracking bugs throughout the development process. If a team member encountered a bug or an issue we would write the it on the board and discuss it at the next meeting. Bug tracking was a process that requires good communication and teamwork as for an issue to be overcome we had to share solutions and potential bug fixes. 
\newline
Throughout the development of this project, we have used many collaboration tools including GitHub, Slack and Discord. While using these tools we were able to communicate new ideas and solutions to problems we may have been facing. GitHub helped us to track our progress and any mistakes that were made we could easily rollback commits. As we are all working on this project remotely, VOIP was incredibly important as we could communicate instantly, raising any issues we may be having and coming to brainstorming a solution.
\subsection{Testing}
Testing was a vital part of the development process. Using Agile required us to test after each feature was incorporated. We used many testing methods during the process of this application the two main testing methods used are White box testing and Black box testing.
\item Selection criteria for algorithms, languages, platforms and technologies.
\end{itemize}
Check out the nice graphs in Figure \ref{tikz:graphs}, and the nice diagram in Figure \ref{tikz:mydiagram}.

\chapter{Experiments}
We tried out many of different experiments throughout the development of our project to improve its user experience and run-times. Between Front End and Back End we tried out many different design patterns and user interfaces that would suit our project and through trial and error found the best suitable solutions to suit our needs. We were able to utilize Googles \href{https://developers.google.com/web/tools/lighthouse/}{\textcolor{blue}{Lighthouse}} performance testing tool, and also the \href{https://developer.chrome.com/docs/devtools/evaluate-performance/}{\textcolor{blue}{Performance}} tab in Chrome DevTools to examine our load times.
\newline

We faced issues while trying to load a large amount of images on a users feed and decided to experiment with ways around this bug. We tried reducing the amount of imported packages and keep the project package small so that it would be less pressure on the website when running. This clean up didn't seem to make any improvements on our website speeds and load times, but was still a successful experiment as it tidied up our code and removed any unnecessary and unwanted external packages.
\newline

Initially, the database models were extremely inefficient as we had entire objects being stored within one another. For example, the society model was storing the entire list of users within that society as user objects which contained unnecessary information like images, names, date of birth, etc [\ref{fig:inefficient_society_model}].

\begin{figure}[H]
    \centering
    \includegraphics[scale=0.8]{img/bad_society_model_1.jpg}
    \caption{Inefficient Society Model}
    \label{fig:inefficient_society_model}
\end{figure}

We then vastly reduced the amount of data shared information between collections within our MongoDB database, instead of passing all of the posting users information we only shared the ID keys which would give us full access to the details of the posting user and the posts information.
Changing this structure within the communication between our collections saved us many resources and storage space within our database. This only marginally improved load times but was a success as it made our website perform at a higher speed than previously, and we learned a new solution to sharing information within our application which could be applied to many other features and functionalities.
\newline

However, even after optimizing the design of the database and making sure that no model contained unnecessary data, the website was still performing extremely poorly on \href{https://developers.google.com/web/tools/lighthouse/}{\textcolor{blue}{Lighthouse}} scores [\ref{fig:poor_lighthouse}]. As you can see from this figure everything except for performance was scored highly, and as the Chrome Devtools only analyze network requests and front-end components, we presumed the problem was within the structure of the database and as we had already restructured the models, we determined that the queries that were providing data to the get requests were the problem.

\begin{figure}[H]
  \centering
  \includegraphics[scale=0.65]{img/lighthouse_poor_cropped.jpg}
  \caption{Poor Lighthouse scores}
  \label{fig:poor_lighthouse}
\end{figure}

After analyzing the performance of the website using the \href{https://developer.chrome.com/docs/devtools/evaluate-performance/}{\textcolor{blue}{Performance}} tab in Google Chrome DevTools tool, which allows you to view network requests, we evaluated that get requests for things such as the discussion feed, society list, or any request that required a large amount of data to be fetched was drastically slowing down load times [\ref{fig:slow_network}]. From this figure we noted that the request for discussion feed data, which included all images, comments, title, etc, was taking significantly longer than other requests. After analyzing the queries, we noted that every field in the \textit{Societies} collection were being returned in the request. And after some requirement analysis, we determined that only a handful of these fields were actually being displayed in the discussion feed component. We then parameterized the database queries, so that the requests could pass in a string with only the required fields for each request, and also a limit variable that limited the amount of documents returned from the query. This greatly increased the flexibility of the queries, as before we had a whole host of overloaded methods for getting different data from the database, and now we only needed a handful of queries to perform the same operations. This increased the performance of the website massively, as the discussion feed was now loading eight times faster, and all other requests were loading much faster too. This also greatly improved Lighthouse performance scores [\ref{fig:improved_lighthouse}].

\begin{figure}[H]
  \centering
  \includegraphics[scale=0.4]{img/slow_network_times.jpg}
  
  \newline
  
  \includegraphics[scale=0.4]{img/improved_network_times.jpg}
  \caption{Slow Requests (Top) vs Improved Requests (Bottom)}
  \label{fig:slow_network}
\end{figure}

\begin{figure}[H]
  \centering
  \includegraphics[scale=0.65]{img/improved_lighthouse.jpg}
  \caption{Improved Lighthouse Performance}
  \label{fig:improved_lighthouse}
\end{figure}

\newline

However, this wasn't the entire issue. Although the performance was better than before, there was clearly still more problems at hand as it was still quite low comparative to other websites, such as Facebook which had a performance of 80 when analyzed with Lighthouse. Through much deliberation and many days of discussion, and after looking through many forums and articles for building fast React applications, we determined that the storage of large photos 

\newline

\begin{itemize}
    \item Website Runtimes
    \item Responsiveness
    \item Speeds and Performance
    \item Loading in images via MongoDB/Amazon
\end{itemize}


\begin{itemize}
    \item Front End
    \item Colorways
    \item UI
    \item FIGMA, WIREFRAME
    \item Design Decisions
    \item Icon imports, Boostrapping
\end{itemize}

Throughout the development of this project we tried out many different User Interfaces and Front-End designs to try and find which was the most suitable layout for our project. We used software such as Figma and Wire framing to design and test our designs which we could implement, once we had three official designs we came to a conclusion on which one would be most suitable for our project to match its features.

\chapter{Technology Review}

\chapter{System Design}

\chapter{System Evaluation}


\chapter{Conclusion}
Overall we have achieved our goal of developing ...

Ultimately, working as a team to produce this project has helped us to develop and improve on our team working skills and problem solving skills.

\chapter{References}


